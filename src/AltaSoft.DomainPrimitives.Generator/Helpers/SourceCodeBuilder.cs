using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AltaSoft.DomainPrimitives.Generator.Helpers;

/// <summary>
/// A utility class for building source code with proper indentation.
/// </summary>
internal sealed class SourceCodeBuilder
{
    private const string SourceHeader1 =
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by '
        """;

    private const string SourceHeader2 =
        """
        '.
        //     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        #nullable enable
        """;

    private readonly StringBuilder _sb;
    private readonly StringBuilder _indentations;

    //private const string IndentationString = "\t";
    private const string IndentationString = "    ";

    private bool _previousWasNewLine;
    private int? _rollbackLength;

    /// <summary>
    /// Initializes a new instance of the <see cref="SourceCodeBuilder"/> class with an optional starting indent level.
    /// </summary>
    /// <param name="startingIndent">The starting indentation level.</param>
    public SourceCodeBuilder(int startingIndent = 0)
    {
        _sb = new StringBuilder();
        _indentations = new StringBuilder();

        if (startingIndent > 0)
        {
            _indentations.Append(GetIndentation(startingIndent));
        }
    }
    /// <summary>
    /// Represents a new line character sequence.
    /// </summary>
    internal static readonly string s_newLine = GetNewLineString();

    /// <summary>
    /// Represents the length of a new line character sequence.
    /// </summary>
    internal static readonly int s_newLineLength = s_newLine.Length;

    /// <summary>
    /// Returns a string containing a new line character sequence.
    /// </summary>
    /// <returns>A string with a new line character sequence.</returns>
    private static string GetNewLineString() => new StringBuilder().AppendLine().ToString();

    /// <summary>
    /// Returns a string that represents the specified number of indentation chars.
    /// </summary>
    /// <param name="count">The number of indentation strings to generate. Default is 1.</param>
    /// <returns>A string that represents the specified number of indentation strings.</returns>
    public static string GetIndentation(int count = 1) => string.Concat(Enumerable.Repeat(IndentationString, count));

    /// <summary>Gets or sets the length of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
    /// <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than zero or greater than <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
    /// <returns>The length of this instance.</returns>
    public int Length
    {
        get => _sb.Length;
        set => _sb.Length = value;
    }

    /// <summary>
    /// Appends indentation to the current string.
    /// </summary>
    /// <param name="count">The number of indentation levels to append. Default is 1.</param>
    public SourceCodeBuilder AppendIndentation(int count = 1) => Append(count == 1 ? IndentationString : string.Concat(Enumerable.Repeat(IndentationString, count)), true);

    /// <summary>
    /// Adds the auto-generated comment to the source code, including the generator name.
    /// </summary>
    /// <param name="generatorName">The name of the source code generator.</param>
    public SourceCodeBuilder AppendSourceHeader(string generatorName) => Append(SourceHeader1).Append(generatorName).AppendLine(SourceHeader2).NewLine();

    /// <summary>
    /// Appends a <c>&lt;inheritdoc/&gt;</c> XML comment.
    /// </summary>
    /// <returns>The updated <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendInheritDoc() => AppendLine("/// <inheritdoc/>");

    /// <summary>
    /// Appends a <c>&lt;inheritdoc/&gt;</c> XML comment with cref.
    /// </summary>
    /// <param name="cref">The cref attribute specifying the member to inherit documentation from.</param>
    /// <returns>The updated <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendInheritDoc(string cref) => AppendLine($"/// <inheritdoc cref=\"{cref}\"/>");

    /// <summary>
    /// Appends a summary documentation block to the source code
    /// </summary>
    /// <param name="summary">The summary text to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendSummary(string summary) => AppendSummaryBlock("summary", summary);

    /// <summary>
    /// Appends a parameter description to the source code builder.
    /// </summary>
    /// <param name="parameterName">The name of the parameter.</param>
    /// <param name="parameterDescription">The description of the parameter.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendParamDescription(string parameterName, string parameterDescription)
    {
        Append("/// <param name=\"").Append(parameterName).Append("\">").Append(parameterDescription).AppendLine("</param>");
        return this;
    }

    /// <summary>
    /// Appends a summary documentation block to the source code
    /// </summary>
    /// <param name="block">The type of block to append (e.g. "summary", "returns")</param>
    /// <param name="line">The text line to include in the block</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendSummaryBlock(string block, string line)
    {
        Append("/// <").Append(block).AppendLine(">").
            Append("/// ").AppendLine(line).
            Append("/// </").Append(block).AppendLine(">");

        return this;
    }

    /// <summary>
    /// Appends a comment line to the source code builder.
    /// </summary>
    /// <param name="commentLine">The comment line to append.</param>
    /// <param name="ensureIndentation">Optional. Specifies whether to ensure proper indentation with <see cref="IndentationString"/>. Default is true.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendComment(string commentLine, bool ensureIndentation = true) => AppendLine("// " + commentLine, ensureIndentation);

    /// <summary>
    /// Appends a class declaration to the source code with the specified modifiers, class name, and optional inheritance.
    /// </summary>
    /// <param name="modifiers">The modifiers for the class (e.g., "public", "internal").</param>
    /// <param name="className">The name of the class to be appended.</param>
    /// <param name="inheritance">Optional. The inheritance or base class for the class declaration.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendClass(string modifiers, string className, string? inheritance = null)
    {
        Append(modifiers).Continue(" class ").Continue(className)
            .ContinueIf(!string.IsNullOrEmpty(inheritance), " : " + inheritance);

        return OpenBracket();
    }

    /// <summary>
    /// Appends a struct declaration to the source code with the specified modifiers, struct name, and optional inheritance.
    /// </summary>
    /// <param name="modifiers">The modifiers for the struct (e.g., "public", "internal").</param>
    /// <param name="className">The name of the struct to be appended.</param>
    /// <param name="inheritance">Optional. The inheritance or base struct for the struct declaration.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendStruct(string modifiers, string className, string? inheritance)
    {
        Append(modifiers).Continue(" struct ").Continue(className)
            .ContinueIf(!string.IsNullOrEmpty(inheritance), " : " + inheritance);

        return OpenBracket();
    }

    /// <summary>
    /// Appends a namespace declaration to the source code with the specified namespace name.
    /// </summary>
    /// <param name="namespace">The name of the namespace to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendNamespace(string @namespace) => Append("namespace ").Continue(@namespace).ContinueLine(";").NewLine();

    /// <summary>
    /// Appends usings by adding using prefix and ; at the end
    /// </summary>
    public SourceCodeBuilder AppendUsings(IEnumerable<string> usings)
    {
        foreach (var us in usings.Distinct())
            Append("using ").Continue(us).ContinueLine(";");

        NewLine();
        return this;
    }

    /// <summary>
    /// Appends the specified string to the source code if a specified condition is met.
    /// </summary>
    /// <param name="condition">A Boolean value indicating whether to append the string.</param>
    /// <param name="line">The string to append if the condition is met.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendIf(bool condition, string line) => !condition ? this : Append(line);

    /// <summary>
    /// Appends the specified string to the source code on a new line if a specified condition is met.
    /// </summary>
    /// <param name="condition">A Boolean value indicating whether to append the string.</param>
    /// <param name="line">The string to append on a new line if the condition is met.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendLineIf(bool condition, string line) => !condition ? this : AppendLine(line);

    /// <summary>
    /// Appends one of two specified strings to the source code on a new line based on a condition.
    /// </summary>
    /// <param name="condition">A Boolean value indicating which string to append.</param>
    /// <param name="ifLine">The string to append on a new line if the condition is true.</param>
    /// <param name="elseLine">The string to append on a new line if the condition is false.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendLineIfElse(bool condition, string ifLine, string elseLine) => AppendLine(condition ? ifLine : elseLine);

    /// <summary>
    /// Appends an opening curly brace "{" on a new line to the source code.
    /// </summary>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder OpenBracket() => AppendLine("{");

    /// <summary>
    /// Appends a closing bracket '}' to the source code on a new line.
    /// </summary>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder CloseBracket() => AppendLine("}");

    /// <summary>
    /// Appends a closing bracket '}' and semicolon ';' to the source code on a new line.
    /// </summary>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder CloseBracketWithSemiColon() => AppendLine("};");

    /// <summary>
    /// Appends a line of text to the source code without adding a newline character, if the input line is not null.
    /// </summary>
    /// <param name="line">The line of text to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder Continue(string? line) => line is null ? this : InternalAppend(line, false, false);

    /// <summary>
    /// Appends a line of text to the source code without adding a newline character if a specified condition is met.
    /// </summary>
    /// <param name="condition">A boolean indicating whether to append the line.</param>
    /// <param name="line">The line of text to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder ContinueIf(bool condition, string line) => !condition ? this : Continue(line);

    /// <summary>
    /// Appends a line of text to the source code without adding a newline character.
    /// </summary>
    /// <param name="line">The line of text to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder ContinueLine(string line) => InternalAppend(line, true, false);

    /// <summary>
    /// Appends a line of text to the source code with an option to ensure proper indentation.
    /// </summary>
    /// <param name="line">The line of text to be appended.</param>
    /// <param name="ensureIndentation">A boolean indicating whether to ensure proper indentation.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder Append(string line, bool ensureIndentation = true) => InternalAppend(line, false, ensureIndentation);

    /// <summary>
    /// Appends a series of lines, separated by newline characters, to the source code.
    /// </summary>
    /// <param name="lines">A string containing multiple lines of text to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendLines(string lines) => AppendLines(lines.Split([s_newLine], StringSplitOptions.None));

    /// <summary>
    /// Appends a collection of lines to the source code, each as a separate line.
    /// </summary>
    /// <param name="lines">An enumerable collection of lines to be appended.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendLines(IEnumerable<string> lines)
    {
        foreach (var line in lines)
        {
            if (line.Length == 0)
            {
                _sb.AppendLine();
            }
            else
            if (line.StartsWith("#"))
            {
                _sb.AppendLine(line);
            }
            else
            {
                _sb.Append(_indentations);
                _sb.AppendLine(line);
            }
        }

        return this;
    }

    /// <summary>
    /// Appends a preprocessor directive to the source code builder.
    /// </summary>
    /// <param name="directive">The preprocessor directive to append.</param>
    /// <returns>A reference to the updated SourceCodeBuilder instance.</returns>
    public SourceCodeBuilder AppendPreProcessorDirective(string directive) => AppendLine($"#{directive}", false);

    /// <summary>
    /// Appends the specified line to the source code with an optional indentation and a newline.
    /// </summary>
    /// <param name="line">The line to append to the source code.</param>
    /// <param name="ensureIndentation">Specifies whether to ensure proper indentation before appending.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder AppendLine(string line, bool ensureIndentation = true) => InternalAppend(line, true, ensureIndentation);

    /// <summary>
    /// Inserts a new line in the source code.
    /// </summary>
    public SourceCodeBuilder NewLine() => InternalAppend(string.Empty, true, false);

    /// <summary>
    /// Saves the current position in a StringBuilder object.
    /// </summary>
    public void SavePosition() => _rollbackLength = _sb.Length;

    /// <summary>
    /// Rolls back the length of the source code builder to a previous state.
    /// </summary>
    /// <param name="length">The length to rollback.</param>
    /// <returns>A reference to this <see cref="SourceCodeBuilder"/> instance.</returns>
    public SourceCodeBuilder Rollback(int length)
    {
        if (_sb.Length != _rollbackLength)
            _sb.Length -= length;

        _rollbackLength = null;
        return this;
    }

    /// <summary>
    /// Gets the string representation of the source code builder.
    /// </summary>
    /// <returns>The source code built using this instance.</returns>
    public override string ToString() => _sb.ToString();

    /// <summary>
    /// Appends the specified line to the source code with optional indentation.
    /// </summary>
    /// <param name="line">The line to append.</param>
    /// <param name="appendNewLine">Whether to append new line</param>
    /// <param name="ensureIndentation">Indicates whether to ensure proper indentation.</param>
    /// <returns>The updated <see cref="SourceCodeBuilder"/> instance.</returns>
    private SourceCodeBuilder InternalAppend(string line, bool appendNewLine, bool ensureIndentation)
    {
        var lineType = CheckIndent(line);

        if (lineType == LineType.ClosingBracket)
            RemoveIndentations();

        if (ensureIndentation && _previousWasNewLine && line.Length > 0)
        {
            _sb.Append(_indentations);
        }

        if (lineType != LineType.Default && !_previousWasNewLine)
        {
            _sb.AppendLine();
            _sb.Append(_indentations);
        }

        if (appendNewLine)
        {
            _sb.AppendLine(line);
            _previousWasNewLine = true;
        }
        else
        {
            _sb.Append(line);
            _previousWasNewLine = false;
        }

        if (lineType == LineType.OpenBracket)
            _indentations.Append(IndentationString);

        return this;
    }

    /// <summary>
    /// Removes one level of indentation.
    /// </summary>
    private void RemoveIndentations() => _indentations.Remove(0, IndentationString.Length);

    /// <summary>
    /// Checks the type of line being appended (e.g., open bracket, closing bracket, or default).
    /// </summary>
    /// <param name="line">The line to check.</param>
    /// <returns>The type of line.</returns>
    private static LineType CheckIndent(string line)
    {
        if (line.StartsWith("{"))
            return LineType.OpenBracket;

        return line.StartsWith("}") ? LineType.ClosingBracket : LineType.Default;
    }

    /// <summary>
    /// Represents the type of line being appended.
    /// </summary>
    private enum LineType
    {
        Default,
        OpenBracket,
        ClosingBracket
    }
}
